#!/usr/bin/env ruby
#
# = NAME
#
# import_hmm_result
#
# = SYNOPSIS
#
# See below, in opt parser block.
#
# = USAGE
#
# See below, in opt parser block.
#
# = AUTHOR
#
# daniel.lundin@scilifelab.se

$VERBOSE = true

require 'optparse'

SEQUENCE_SOURCES = {
  'ncbi_nr' => {
    source: 'NCBI',
    name:   'NR'
  }
}
@options = {
  dbuser: '',
  dryrun: false
}
opt_parser = OptionParser.new do |opts|
  opts.banner = <<BANNER
import_hmm_result: Reads a HMM result in table format (.tblout) and inserts
  rows into hmm_results and hmm_result_rows.
    import_hmm_result [options] protein_name.tblout
BANNER

  opts.on "--db=STRING", "Database to connect to (default as UNIX user, but see --dbuser)" do |v|
    @options[:db] = v
  end

  opts.on "--dbuser=STRING", "Database user to connect as" do |v|
    @options[:dbuser] = "-U #{v}"
  end

  opts.on "--[no-]dryrun", "Just do a dry run, echoing commands sent to psql, default #{@options[:dryrun]}" do |v|
    @options[:dryrun] = v
  end

  opts.on "-h", "--help", "This info"  do
    puts opts
    exit 0
  end

  opts.on "--ssversion=STRING", "Sequence source version (usually a date string)" do |v|
    @options[:ssversion] = v
  end

  opts.on "-v", "--verbose", "Be verbose"  do |v| 
    @options[:verbose] = v 
  end
end

begin
  opt_parser.parse!
  mandatory = [ :db, :ssversion ]
  missing = mandatory.select { |param| @options[param].nil? }
  unless missing.empty?
    warn "Missing options: #{missing.map { |m| "--#{m}" }.join(", ")}"
    warn opt_parser
    exit 1
  end
rescue OptionParser::InvalidOption, OptionParser::MissingArgument
  warn "#{$!}"
  warn opt_parser
  exit 1
end

# Parse the file name
@infile = ARGV.shift

unless @infile and File.exists?(@infile) then
  warn "You must provide an existing infile"
  exit 2
end

( @options[:protein_name], @options[:sequence_source] ) = File.basename(@infile).split('.')
 
def _call_psql(sql, pipe = nil)
  psqlcall = pipe ? "#{pipe} | " : ""
  psqlcall = "psql #{@options[:dbuser]} -d #{@options[:db]} -c \"#{sql}\""
  if @options[:dryrun]
    puts "DRY RUN: psql call: #{psqlcall}"
  else
    unless system(psqlcall)
      warn "Failed to call #{psqlcall}"
      exit 2
    end
  end
end

def _select_psql(sql)
  psqlcall = "psql #{@options[:dbuser]} -d #{@options[:db]} --tuples-only -c \"#{sql}\" | sed 's/^ *//' |grep -v '^$' | sed 's/ *| */\t/g'"
  if @options[:dryrun]
    puts "DRY RUN: psql call: #{psqlcall}"
    []
  else
    `#{psqlcall}`.split(/\t/)
  end
end

# 1. Delete any old hmm_result
warn "Deleting any hmm_result for #{@options[:protein_name]}, #{@options[:sequence_source]}-#{@options[:ssversion]}" if @options[:verbose]
_call_psql(<<-SQL)
  DELETE FROM hmm_results
  WHERE 
    hmm_profile_id = ( SELECT id FROM hmm_profiles WHERE protein_name = '#{@options[:protein_name]}' ) AND
    sequence_source_id = ( 
      SELECT ID FROM sequence_sources 
      WHERE 
	source = '#{SEQUENCE_SOURCES[@options[:sequence_source]][:source]}' AND
	name = '#{SEQUENCE_SOURCES[@options[:sequence_source]][:name]}' AND
	version = '#{@options[:ssversion]}'
    )
SQL
warn "Done." if @options[:verbose]

# 2. Insert a new hmm_result
warn "Inserting new hmm_result for #{@options[:protein_name]}, #{@options[:sequence_source]}-#{@options[:ssversion]}" if @options[:verbose]
_call_psql(<<-SQL)
  INSERT INTO hmm_results(hmm_profile_id, sequence_source_id, executed, created_at, updated_at)
  SELECT hp.id,ss.id,now(),now(),now() 
  FROM hmm_profiles hp, sequence_sources ss
  WHERE 
    hp.protein_name = '#{@options[:protein_name]}' AND
    ss.source = '#{SEQUENCE_SOURCES[@options[:sequence_source]][:source]}' AND
    ss.name = '#{SEQUENCE_SOURCES[@options[:sequence_source]][:name]}' AND
    ss.version = '#{@options[:ssversion]}'
SQL
@hmm_profile_id = _select_psql(<<-SQL)
  SELECT id FROM hmm_results hr
  WHERE 
    hr.hmm_profile_id = ( SELECT id FROM hmm_profiles hp WHERE hp.protein_name = '#{@options[:protein_name]}' ) AND
    hr.sequence_source_id = (
      SELECT id
      FROM sequence_sources ss
      WHERE
	ss.source = '#{SEQUENCE_SOURCES[@options[:sequence_source]][:source]}' AND
	ss.name = '#{SEQUENCE_SOURCES[@options[:sequence_source]][:name]}' AND
	ss.version = '#{@options[:ssversion]}'
    )
SQL
warn "Done." if @options[:verbose]

# 3. Insert rows
warn "Inserting result rows from #{@infile}" if @options[:verbose]

begin
  File.new(@infile).each do |line|
    next if line =~ /^#/
    fields = line.split(/\s+/)

    # Check if this sequence is already registered as a db_sequence
    tfields = fields[0].split('|')
    @db_sequence_id = _select_psql("SELECT id FROM db_entries WHERE gi = #{tfields[1]}")[0]
    unless @db_sequence_id
      @db_sequence_id = _select_psql(<<-SQL)[0]
        INSERT INTO db_sequences(created_at,updated_at) SELECT now(), now();
	SELECT max(id) FROM db_sequences;
      SQL
    end

    # Insert all db_entries (will generate errors for gis that are already present)
    _call_psql(<<-SQL)
      INSERT INTO db_entries(db_sequence_id, gi, db, acc, created_at, updated_at)
      VALUES(#{@db_sequence_id}, #{tfields[1]}, '#{tfields[2]}', '#{tfields[3]}', now(), now())
    SQL
    fields[-1].split(/\001/).each do |db_entry|
    end
#    _call_psql(<<-SQL)
#      INSERT INTO hmm_result_rows(
#	target_name, target_acc, query_name, query_acc, fullseq_evalue, fullseq_score, fullseq_bias, bestdom_evalue, bestdom_score, bestdom_bias, domnumest_exp, domnumest_reg, domnumest_clu, domnumest_ov, domnumest_env, domnumest_rep, domnumest_inc, domnumest_dom, created_at, updated_at, hmm_result_id
#      )
#      VALUES(
#      )
#    SQL
  end
rescue
  warn "Failed to read #{@infile}: #{$!}, backtrace:\n\t#{$!.backtrace.join("\n\t")}"
  exit 2
end
warn "Done." if @options[:verbose]
exit 1
