#!/usr/bin/env ruby
#
# = NAME
#
# import_hmm_result
#
# = SYNOPSIS
#
# See below, in opt parser block.
#
# = USAGE
#
# See below, in opt parser block.
#
# = AUTHOR
#
# daniel.lundin@scilifelab.se

$VERBOSE = true

require 'optparse'

SEQUENCE_SOURCES = {
  'ncbi_nr' => {
    source: 'NCBI',
    name:   'NR'
  }
}
@options = {
  dbuser: '',
  dryrun: false
}
opt_parser = OptionParser.new do |opts|
  opts.banner = <<BANNER
import_hmm_result: Reads a HMM result in table format (.tblout) and inserts
  rows into hmm_results and hmm_result_rows.
    import_hmm_result [options] protein_name.tblout
BANNER

  opts.on "--db=STRING", "Database to connect to (default as UNIX user, but see --dbuser)" do |v|
    @options[:db] = v
  end

  opts.on "--dbuser=STRING", "Database user to connect as" do |v|
    @options[:dbuser] = "-U #{v}"
  end

  opts.on "--[no-]dryrun", "Just do a dry run, echoing commands sent to psql, default #{@options[:dryrun]}" do |v|
    @options[:dryrun] = v
  end

  opts.on "-h", "--help", "This info"  do
    puts opts
    exit 0
  end

  opts.on "--ssversion=STRING", "Sequence source version (usually a date string)" do |v|
    @options[:ssversion] = v
  end

  opts.on "-v", "--verbose", "Be verbose"  do |v| 
    @options[:verbose] = v 
  end
end

begin
  opt_parser.parse!
  mandatory = [ :db, :ssversion ]
  missing = mandatory.select { |param| @options[param].nil? }
  unless missing.empty?
    warn "Missing options: #{missing.map { |m| "--#{m}" }.join(", ")}"
    warn opt_parser
    exit 1
  end
rescue OptionParser::InvalidOption, OptionParser::MissingArgument
  warn "#{$!}"
  warn opt_parser
  exit 1
end

# Parse the file name
@infile = ARGV.shift

unless @infile and File.exists?(@infile) then
  warn "You must provide an existing infile"
  exit 2
end

( @options[:protein_name], @options[:sequence_source] ) = File.basename(@infile).split('.')
 
def _call_psql(sql, fname = nil)
  psqlcall = "psql #{@options[:dbuser]} -d #{@options[:db]} -c '#{sql}'"
  psqlcall += " < #{fname}" if fname
  if @options[:dryrun]
    puts "DRY RUN: psql call: #{psqlcall}"
  else
    unless system(psqlcall)
      warn "Failed to call #{psqlcall}"
      exit 2
    end
  end
end

# 1. Delete any old hmm_result
warn "Deleting any hmm_result for #{@options[:protein_name]}, #{@options[:sequence_source]}-#{@options[:ssversion]}" if @options[:verbose]
_call_psql(<<-SQL)
  DELETE FROM hmm_results
  WHERE 
    hmm_profile_id = ( SELECT id FROM hmm_profiles WHERE protein_name = '#{@options[:protein_name]}' ) AND
    sequence_source_id = ( 
      SELECT ID FROM sequence_sources 
      WHERE 
	source = '#{SEQUENCE_SOURCES[@options[:sequence_source]][:source]}' AND
	name = '#{SEQUENCE_SOURCES[@options[:sequence_source]][:name]}' AND
	version = '#{@options[:ssversion]}'
    )
SQL
warn "Done." if @options[:verbose]

# 2. Insert a new hmm_result
warn "Inserting new hmm_result for #{@options[:protein_name]}, #{@options[:sequence_source]}-#{@options[:ssversion]}" if @options[:verbose]
_call_psql(<<-SQL)
  INSERT INTO hmm_results(hmm_profile_id, sequence_source_id, executed, created_at, updated_at)
  SELECT hp.id,ss.id,now(),now(),now() 
  FROM hmm_profiles hp, sequence_sources ss
  WHERE 
    hp.protein_name = '#{@options[:protein_name]}' AND
    ss.source = '#{SEQUENCE_SOURCES[@options[:sequence_source]][:source]}'
    ss.name = '#{SEQUENCE_SOURCES[@options[:sequence_source]][:name]}'
    ss.version = '#{@options[:ssversion]}'
SQL
warn "Done." if @options[:verbose]
exit 1

# 2. Loop and create partition tables with indexes
partnum = 0
partfile = _partfile(partnum)
lastgi = nil
firstgi = 0
warn "Creating partitioned tables..." if @options[:verbose]
IO.popen("gunzip -c #{@infile} | sort -n").each_with_index do |line, i|
  gi = line.split("\t")[0].to_i
  
  if i > 0 and i % @options[:partition_size] == 0
    partfile.close
    _handle_parttable(partnum, firstgi, gi)
    firstgi = lastgi
    partnum += 1
    partfile = _partfile(partnum)
  end

  next if gi == lastgi

  lastgi = gi
  
  partfile.print line
end
warn "Done." if @options[:verbose]

partfile.close
_handle_parttable(partnum, firstgi, lastgi)
